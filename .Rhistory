# NO LONGER NEEDED -- VISUALIZES A SINGLE OUTBREAK
# # Call the spread function and save the result
results <- spread()
# Plot the results
ggplot(data = results, aes(x = time, y = I)) +
geom_line()
outbreak.size(results)
# Initialize an empty data frame in which store results
results <- data.frame(num.groups = numeric(),
group.size = numeric(),
outbreak.size = numeric())
# Loop through values for num.groups
for(i in seq(from = 500, to = 10000, by = 500)) {
# Loop through values for group.size
for(j in seq(from = 1, to = 20, by = 1)) {
num.groups <- i
group.size <- j
# Create new data frame to store a single row of data for this run
result <- data.frame(num.groups = i,
group.size = j,
outbreak.size = outbreak.size(spread()))
results[nrow(results) + 1,] <- result
}
}
# Save the results
write.csv(results, "results.csv")
# Visualize the results
ggplot(data = results, aes(x = num.groups,
y = group.size,
z = outbreak.size)) +
stat_summary_2d(bins = c(19, 19))
# Create the initial population
N = 1000  # total population
I.prop = 0.01  # proportion infected
I = round(N * I.prop)  # initial number infected
S = N - I
R = 0
t.max = 1000  # maximum timestep (run duration)
pop = c(rep(0, S), rep(1, R), rep(2, I))
# Value = 0 means susceptible
# Value = 1 means removed
# Value >= 2 means infected
# Set other model parameters
p.transmit <- 1
num.groups <- 5000
group.size <- 4
t.recovery <- 30
# Spread function
# 1st arg = population vector for previous time period
# 2nd arg = current time step
spread <- function(population = pop, timestep = 0, history = NULL) {
# Save a new copy of the population
pop.copy <- population
# If history is null
if(is.null(history)) {
# Create a new data frame to store the population history.
hist.df <- data.frame(time = numeric(),
S = numeric(),
I = numeric(),
R = numeric())
} else {
hist.df = history
}
# Add a single row containing the counts of each population type.
hist.df[nrow(hist.df) + 1,] <- list(timestep,
length(pop.copy[pop.copy == 0]),
length(pop.copy[pop.copy >= 2]),
length(pop.copy[pop.copy == 1]))
# Randomly sample the population a number of times equal to num.groups.
# Each sample corresponds to a social gathering.
for(i in num.groups) {
# Sample a number of indices in population equal to group.size
indices <- sample(1:length(pop.copy), group.size)
# Create a counter to store the number of infected people in the group
I.here <- 0
# Check whether each person in pop at the indices sampled is infected
for(j in indices) {
# If the person is infected, increase I.here by 1
if(pop.copy[j] >= 2) {
I.here <- I.here + 1
}
}
# If I.here > 0...
if(I.here > 0) {
# Check whether each person in pop at the indices sampled is susceptible
for (j in indices) {
# If the person is susceptible...
if(pop.copy[j] == 0) {
# Change the person to infected with a probability of p.transmit
# for EACH infected person in the group.
if(min(runif(I.here, 0, 1)) < p.transmit) {
pop.copy[j] <- 2
}
}
}
}
}
# Check if each person in the population is infected
for(i in 1:length(pop.copy)) {
# If the person is infected...
if(pop.copy[i] >= 2) {
# Increment the person's state by 1/t.recovery.
pop.copy[i] <- pop.copy[i] + 1 / t.recovery
# If the person's state >= 3, change the person's status to
# recovered.
if(pop.copy[i] >= 3) {
pop.copy[i] <- 1
}
}
}
# If we're about to the maximum time step...
if (timestep == t.max - 1) {
# Append the updated S, I, and R counts to hist.df
# Add a single row containing the counts of each population type.
hist.df[nrow(hist.df) + 1,] <- list(timestep + 1,
length(pop.copy[pop.copy == 0]),
length(pop.copy[pop.copy >= 2]),
length(pop.copy[pop.copy == 1]))
# Output the population history
return(hist.df)
} else {
# Call this function recursively with the updated population and history
# and with timestep incremented by 1.
spread(pop.copy, timestep + 1, hist.df)
}
}
# Outbreak size function. Calculates I + R at last timestep of an outbreak.
outbreak.size <- function(outbreak) {
return(outbreak$I[length(outbreak$I)] + outbreak$R[length(outbreak$R)])
}
# Libraries
library(ggplot2)
# NO LONGER NEEDED -- VISUALIZES A SINGLE OUTBREAK
# # Call the spread function and save the result
results <- spread()
# Plot the results
ggplot(data = results, aes(x = time, y = I)) +
geom_line()
outbreak.size(results)
# Initialize an empty data frame in which store results
results <- data.frame(num.groups = numeric(),
group.size = numeric(),
outbreak.size = numeric())
# Loop through values for num.groups
for(i in seq(from = 500, to = 10000, by = 500)) {
# Loop through values for group.size
for(j in seq(from = 1, to = 20, by = 1)) {
num.groups <- i
group.size <- j
# Create new data frame to store a single row of data for this run
result <- data.frame(num.groups = i,
group.size = j,
outbreak.size = outbreak.size(spread()))
results[nrow(results) + 1,] <- result
}
}
# Save the results
write.csv(results, "results.csv")
# Visualize the results
ggplot(data = results, aes(x = num.groups,
y = group.size,
z = outbreak.size)) +
stat_summary_2d(bins = c(19, 19))
View(results)
results <- spread()
# Plot the results
ggplot(data = results, aes(x = time, y = I)) +
geom_line()
outbreak.size(results)
# Create the initial population
N = 1000  # total population
I.prop = 0.01  # proportion infected
I = round(N * I.prop)  # initial number infected
S = N - I
R = 0
t.max = 1000  # maximum timestep (run duration)
pop = c(rep(0, S), rep(1, R), rep(2, I))
# Value = 0 means susceptible
# Value = 1 means removed
# Value >= 2 means infected
# Set other model parameters
p.transmit <- 1
num.groups <- 5000
group.size <- 3
t.recovery <- 30
# Spread function
# 1st arg = population vector for previous time period
# 2nd arg = current time step
spread <- function(population = pop, timestep = 0, history = NULL) {
# Save a new copy of the population
pop.copy <- population
# If history is null
if(is.null(history)) {
# Create a new data frame to store the population history.
hist.df <- data.frame(time = numeric(),
S = numeric(),
I = numeric(),
R = numeric())
} else {
hist.df = history
}
# Add a single row containing the counts of each population type.
hist.df[nrow(hist.df) + 1,] <- list(timestep,
length(pop.copy[pop.copy == 0]),
length(pop.copy[pop.copy >= 2]),
length(pop.copy[pop.copy == 1]))
# Randomly sample the population a number of times equal to num.groups.
# Each sample corresponds to a social gathering.
for(i in num.groups) {
# Sample a number of indices in population equal to group.size
indices <- sample(1:length(pop.copy), group.size)
# Create a counter to store the number of infected people in the group
I.here <- 0
# Check whether each person in pop at the indices sampled is infected
for(j in indices) {
# If the person is infected, increase I.here by 1
if(pop.copy[j] >= 2) {
I.here <- I.here + 1
}
}
# If I.here > 0...
if(I.here > 0) {
# Check whether each person in pop at the indices sampled is susceptible
for (j in indices) {
# If the person is susceptible...
if(pop.copy[j] == 0) {
# Change the person to infected with a probability of p.transmit
# for EACH infected person in the group.
if(min(runif(I.here, 0, 1)) < p.transmit) {
pop.copy[j] <- 2
}
}
}
}
}
# Check if each person in the population is infected
for(i in 1:length(pop.copy)) {
# If the person is infected...
if(pop.copy[i] >= 2) {
# Increment the person's state by 1/t.recovery.
pop.copy[i] <- pop.copy[i] + 1 / t.recovery
# If the person's state >= 3, change the person's status to
# recovered.
if(pop.copy[i] >= 3) {
pop.copy[i] <- 1
}
}
}
# If we're about to the maximum time step...
if (timestep == t.max - 1) {
# Append the updated S, I, and R counts to hist.df
# Add a single row containing the counts of each population type.
hist.df[nrow(hist.df) + 1,] <- list(timestep + 1,
length(pop.copy[pop.copy == 0]),
length(pop.copy[pop.copy >= 2]),
length(pop.copy[pop.copy == 1]))
# Output the population history
return(hist.df)
} else {
# Call this function recursively with the updated population and history
# and with timestep incremented by 1.
spread(pop.copy, timestep + 1, hist.df)
}
}
# Outbreak size function. Calculates I + R at last timestep of an outbreak.
outbreak.size <- function(outbreak) {
return(outbreak$I[length(outbreak$I)] + outbreak$R[length(outbreak$R)])
}
# Create the initial population
N = 1000  # total population
I.prop = 0.01  # proportion infected
I = round(N * I.prop)  # initial number infected
S = N - I
R = 0
t.max = 1000  # maximum timestep (run duration)
pop = c(rep(0, S), rep(1, R), rep(2, I))
# Value = 0 means susceptible
# Value = 1 means removed
# Value >= 2 means infected
# Set other model parameters
p.transmit <- 1
num.groups <- 5000
group.size <- 3
t.recovery <- 30
# Spread function
# 1st arg = population vector for previous time period
# 2nd arg = current time step
spread <- function(population = pop, timestep = 0, history = NULL) {
# Save a new copy of the population
pop.copy <- population
# If history is null
if(is.null(history)) {
# Create a new data frame to store the population history.
hist.df <- data.frame(time = numeric(),
S = numeric(),
I = numeric(),
R = numeric())
} else {
hist.df = history
}
# Add a single row containing the counts of each population type.
hist.df[nrow(hist.df) + 1,] <- list(timestep,
length(pop.copy[pop.copy == 0]),
length(pop.copy[pop.copy >= 2]),
length(pop.copy[pop.copy == 1]))
# Randomly sample the population a number of times equal to num.groups.
# Each sample corresponds to a social gathering.
for(i in num.groups) {
# Sample a number of indices in population equal to group.size
indices <- sample(1:length(pop.copy), group.size)
# Create a counter to store the number of infected people in the group
I.here <- 0
# Check whether each person in pop at the indices sampled is infected
for(j in indices) {
# If the person is infected, increase I.here by 1
if(pop.copy[j] >= 2) {
I.here <- I.here + 1
}
}
# If I.here > 0...
if(I.here > 0) {
# Check whether each person in pop at the indices sampled is susceptible
for (j in indices) {
# If the person is susceptible...
if(pop.copy[j] == 0) {
# Change the person to infected with a probability of p.transmit
# for EACH infected person in the group.
if(min(runif(I.here, 0, 1)) < p.transmit) {
pop.copy[j] <- 2
}
}
}
}
}
# Check if each person in the population is infected
for(i in 1:length(pop.copy)) {
# If the person is infected...
if(pop.copy[i] >= 2) {
# Increment the person's state by 1/t.recovery.
pop.copy[i] <- pop.copy[i] + 1 / t.recovery
# If the person's state >= 3, change the person's status to
# recovered.
if(pop.copy[i] >= 3) {
pop.copy[i] <- 1
}
}
}
# If we're about to the maximum time step...
if (timestep == t.max - 1) {
# Append the updated S, I, and R counts to hist.df
# Add a single row containing the counts of each population type.
hist.df[nrow(hist.df) + 1,] <- list(timestep + 1,
length(pop.copy[pop.copy == 0]),
length(pop.copy[pop.copy >= 2]),
length(pop.copy[pop.copy == 1]))
# Output the population history
return(hist.df)
} else {
# Call this function recursively with the updated population and history
# and with timestep incremented by 1.
spread(pop.copy, timestep + 1, hist.df)
}
}
# Outbreak size function. Calculates I + R at last timestep of an outbreak.
outbreak.size <- function(outbreak) {
return(outbreak$I[length(outbreak$I)] + outbreak$R[length(outbreak$R)])
}
# NO LONGER NEEDED -- VISUALIZES A SINGLE OUTBREAK
# # Call the spread function and save the result
results <- spread()
# Plot the results
ggplot(data = results, aes(x = time, y = I)) +
geom_line()
outbreak.size(results)
# Initialize an empty data frame in which store results
results <- data.frame(num.groups = numeric(),
group.size = numeric(),
outbreak.size = numeric())
# Create the initial population
N = 1000  # total population
I.prop = 0.01  # proportion infected
I = round(N * I.prop)  # initial number infected
S = N - I
R = 0
t.max = 1000  # maximum timestep (run duration)
pop = c(rep(0, S), rep(1, R), rep(2, I))
# Value = 0 means susceptible
# Value = 1 means removed
# Value >= 2 means infected
# Set other model parameters
p.transmit <- 1
num.groups <- 5000
group.size <- 10
t.recovery <- 30
# Spread function
# 1st arg = population vector for previous time period
# 2nd arg = current time step
spread <- function(population = pop, timestep = 0, history = NULL) {
# Save a new copy of the population
pop.copy <- population
# If history is null
if(is.null(history)) {
# Create a new data frame to store the population history.
hist.df <- data.frame(time = numeric(),
S = numeric(),
I = numeric(),
R = numeric())
} else {
hist.df = history
}
# Add a single row containing the counts of each population type.
hist.df[nrow(hist.df) + 1,] <- list(timestep,
length(pop.copy[pop.copy == 0]),
length(pop.copy[pop.copy >= 2]),
length(pop.copy[pop.copy == 1]))
# Randomly sample the population a number of times equal to num.groups.
# Each sample corresponds to a social gathering.
for(i in num.groups) {
# Sample a number of indices in population equal to group.size
indices <- sample(1:length(pop.copy), group.size)
# Create a counter to store the number of infected people in the group
I.here <- 0
# Check whether each person in pop at the indices sampled is infected
for(j in indices) {
# If the person is infected, increase I.here by 1
if(pop.copy[j] >= 2) {
I.here <- I.here + 1
}
}
# If I.here > 0...
if(I.here > 0) {
# Check whether each person in pop at the indices sampled is susceptible
for (j in indices) {
# If the person is susceptible...
if(pop.copy[j] == 0) {
# Change the person to infected with a probability of p.transmit
# for EACH infected person in the group.
if(min(runif(I.here, 0, 1)) < p.transmit) {
pop.copy[j] <- 2
}
}
}
}
}
# Check if each person in the population is infected
for(i in 1:length(pop.copy)) {
# If the person is infected...
if(pop.copy[i] >= 2) {
# Increment the person's state by 1/t.recovery.
pop.copy[i] <- pop.copy[i] + 1 / t.recovery
# If the person's state >= 3, change the person's status to
# recovered.
if(pop.copy[i] >= 3) {
pop.copy[i] <- 1
}
}
}
# If we're about to the maximum time step...
if (timestep == t.max - 1) {
# Append the updated S, I, and R counts to hist.df
# Add a single row containing the counts of each population type.
hist.df[nrow(hist.df) + 1,] <- list(timestep + 1,
length(pop.copy[pop.copy == 0]),
length(pop.copy[pop.copy >= 2]),
length(pop.copy[pop.copy == 1]))
# Output the population history
return(hist.df)
} else {
# Call this function recursively with the updated population and history
# and with timestep incremented by 1.
spread(pop.copy, timestep + 1, hist.df)
}
}
# Outbreak size function. Calculates I + R at last timestep of an outbreak.
outbreak.size <- function(outbreak) {
return(outbreak$I[length(outbreak$I)] + outbreak$R[length(outbreak$R)])
}
# Libraries
library(ggplot2)
# NO LONGER NEEDED -- VISUALIZES A SINGLE OUTBREAK
# # Call the spread function and save the result
# results <- spread()
#
# # Plot the results
# ggplot(data = results, aes(x = time, y = I)) +
#   geom_line()
#
# outbreak.size(results)
# Initialize an empty data frame in which store results
results <- data.frame(num.groups = numeric(),
group.size = numeric(),
outbreak.size = numeric())
# Loop through values for num.groups
for(i in seq(from = 500, to = 10000, by = 500)) {
# Loop through values for group.size
for(j in seq(from = 1, to = 20, by = 1)) {
num.groups <- i
group.size <- j
# Create new data frame to store a single row of data for this run
result <- data.frame(num.groups = i,
group.size = j,
outbreak.size = outbreak.size(spread()))
results[nrow(results) + 1,] <- result
}
}
# Save the results
write.csv(results, "results.csv")
# Visualize the results
ggplot(data = results, aes(x = num.groups,
y = group.size,
z = outbreak.size)) +
stat_summary_2d(bins = c(19, 19))
